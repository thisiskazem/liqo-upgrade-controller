/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"strings"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/yaml"

	upgradev1alpha1 "github.com/thisiskazem/liqo-upgrade-controller/api/v1alpha1"
)

// CompatibilityMatrix represents the version compatibility data
type CompatibilityMatrix map[string][]string

// Stage 0: Start & Validation
func (r *LiqoUpgradeReconciler) startValidation(ctx context.Context, upgrade *upgradev1alpha1.LiqoUpgrade) (ctrl.Result, error) {
	logger := log.FromContext(ctx)
	logger.Info("Stage 0: Starting validation phase")

	// Initialize status
	upgrade.Status.TotalStages = 9 // Stage 0-8 per design (now implementing through Stage 3)
	upgrade.Status.CurrentStage = 0

	return r.updateStatus(ctx, upgrade, upgradev1alpha1.PhaseValidating, "Validating compatibility and prerequisites", nil)
}

func (r *LiqoUpgradeReconciler) performValidation(ctx context.Context, upgrade *upgradev1alpha1.LiqoUpgrade) (ctrl.Result, error) {
	logger := log.FromContext(ctx)
	logger.Info("Performing validation checks")

	namespace := upgrade.Spec.Namespace
	if namespace == "" {
		namespace = "liqo"
	}

	// Step 1: Verify cluster identity
	logger.Info("Step 1: Verifying cluster identity")
	if err := r.verifyClusterIdentity(ctx, namespace); err != nil {
		return r.fail(ctx, upgrade, fmt.Sprintf("Cluster identity verification failed: %v", err))
	}

	// Step 2: Detect local cluster version from liqo-controller-manager image
	logger.Info("Step 2: Detecting local cluster Liqo version")
	localVersion, err := r.detectDeployedVersion(ctx, namespace)
	if err != nil {
		return r.fail(ctx, upgrade, fmt.Sprintf("Failed to detect local cluster version: %v", err))
	}
	logger.Info("Local cluster version detected", "version", localVersion)

	// Step 3: Get remote cluster versions from ForeignCluster CRs
	logger.Info("Step 3: Getting remote cluster versions from ForeignCluster CRs")
	remoteVersions, err := r.getRemoteClusterVersions(ctx, localVersion)
	if err != nil {
		return r.fail(ctx, upgrade, fmt.Sprintf("Failed to get remote cluster versions: %v", err))
	}

	// Step 4: Find minimum version among all versions (local + remotes)
	logger.Info("Step 4: Finding minimum version among all clusters")
	allVersions := append([]string{localVersion}, remoteVersions...)
	minimumVersion := r.findMinimumVersion(allVersions)
	logger.Info("Minimum version across all clusters", "version", minimumVersion)

	// Step 5: Load compatibility matrix and check if minimum version can upgrade to target
	logger.Info("Step 5: Checking compatibility matrix")
	matrix, err := r.loadCompatibilityMatrix(ctx, namespace)
	if err != nil {
		return r.fail(ctx, upgrade, fmt.Sprintf("Failed to load compatibility matrix: %v", err))
	}

	if !r.isCompatible(matrix, minimumVersion, upgrade.Spec.TargetVersion) {
		return r.fail(ctx, upgrade, fmt.Sprintf("Incompatible upgrade: minimum version %s cannot upgrade to %s", minimumVersion, upgrade.Spec.TargetVersion))
	}
	logger.Info("Compatibility check passed", "from", minimumVersion, "to", upgrade.Spec.TargetVersion)

	// Step 6: Backup critical environment variables and flags
	logger.Info("Step 6: Backing up environment variables and configuration")
	if err := r.backupEnvironmentConfig(ctx, upgrade, namespace); err != nil {
		return r.fail(ctx, upgrade, fmt.Sprintf("Failed to backup environment config: %v", err))
	}

	// Step 7: Check component health
	logger.Info("Step 7: Checking component health")
	if err := r.verifyComponentHealth(ctx, namespace); err != nil {
		return r.fail(ctx, upgrade, fmt.Sprintf("Component health check failed: %v", err))
	}

	// Step 8: Save previous version (local version)
	upgrade.Status.PreviousVersion = localVersion

	// Add Compatible condition
	condition := metav1.Condition{
		Type:               string(upgradev1alpha1.ConditionCompatible),
		Status:             metav1.ConditionTrue,
		LastTransitionTime: metav1.Now(),
		Reason:             "ValidationPassed",
		Message:            fmt.Sprintf("Minimum version %s â†’ %s is compatible", minimumVersion, upgrade.Spec.TargetVersion),
	}

	statusUpdates := map[string]interface{}{
		"previousVersion": localVersion,
		"conditions":      []metav1.Condition{condition},
		"backupReady":     upgrade.Status.BackupReady,
		"backupName":      upgrade.Status.BackupName,
	}

	if _, err := r.updateStatus(ctx, upgrade, upgradev1alpha1.PhaseValidating, "Validation completed successfully", statusUpdates); err != nil {
		return ctrl.Result{}, err
	}

	// Move to next phase: Freeze operations
	return r.startFreezeOperations(ctx, upgrade)
}

func (r *LiqoUpgradeReconciler) verifyClusterIdentity(ctx context.Context, namespace string) error {
	// Verify ForeignCluster CRD exists
	deployment := &appsv1.Deployment{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      "liqo-controller-manager",
		Namespace: namespace,
	}, deployment)
	return err
}

func (r *LiqoUpgradeReconciler) detectDeployedVersion(ctx context.Context, namespace string) (string, error) {
	deployment := &appsv1.Deployment{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      "liqo-controller-manager",
		Namespace: namespace,
	}, deployment)
	if err != nil {
		return "", err
	}

	if len(deployment.Spec.Template.Spec.Containers) == 0 {
		return "", fmt.Errorf("no containers found in deployment")
	}

	image := deployment.Spec.Template.Spec.Containers[0].Image
	parts := strings.Split(image, ":")
	if len(parts) < 2 {
		return "", fmt.Errorf("invalid image format: %s", image)
	}

	version := parts[len(parts)-1]
	if !strings.HasPrefix(version, "v") {
		version = "v" + version
	}

	return version, nil
}

func (r *LiqoUpgradeReconciler) verifyComponentHealth(ctx context.Context, namespace string) error {
	deployment := &appsv1.Deployment{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      "liqo-controller-manager",
		Namespace: namespace,
	}, deployment)
	if err != nil {
		return err
	}

	if deployment.Status.ReadyReplicas < 1 {
		return fmt.Errorf("liqo-controller-manager not ready: %d/%d", deployment.Status.ReadyReplicas, *deployment.Spec.Replicas)
	}

	return nil
}

// backupEnvironmentConfig backs up critical environment variables and configuration
func (r *LiqoUpgradeReconciler) backupEnvironmentConfig(ctx context.Context, upgrade *upgradev1alpha1.LiqoUpgrade, namespace string) error {
	logger := log.FromContext(ctx)

	// Create a ConfigMap to store environment variable backups
	backupConfigMapName := fmt.Sprintf("liqo-upgrade-env-backup-%s", upgrade.Name)

	// Get liqo-controller-manager deployment
	deployment := &appsv1.Deployment{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      "liqo-controller-manager",
		Namespace: namespace,
	}, deployment)
	if err != nil {
		return fmt.Errorf("failed to get controller-manager deployment: %w", err)
	}

	// Extract environment variables from all containers
	envData := make(map[string]string)
	for _, container := range deployment.Spec.Template.Spec.Containers {
		for _, env := range container.Env {
			key := fmt.Sprintf("%s_%s", container.Name, env.Name)
			if env.Value != "" {
				envData[key] = env.Value
			} else if env.ValueFrom != nil {
				// Store reference info for ValueFrom
				envData[key+"_type"] = "valueFrom"
			}
		}

		// Store container args/command
		if len(container.Args) > 0 {
			envData[container.Name+"_args"] = strings.Join(container.Args, " ")
		}
		if len(container.Command) > 0 {
			envData[container.Name+"_command"] = strings.Join(container.Command, " ")
		}
	}

	// Critical environment variables that must be preserved (Stage 2)
	criticalEnvVars := []string{
		"POD_NAMESPACE",
		"CLUSTER_ID",
		"TENANT_NAMESPACE",
		"CLUSTER_ROLE",
		"ENABLE_IPAM",
		"LOG_LEVEL",
	}

	// Verify critical env vars are present
	for _, envVar := range criticalEnvVars {
		found := false
		for key := range envData {
			if strings.Contains(key, envVar) {
				found = true
				break
			}
		}
		if !found {
			logger.Info("Warning: critical environment variable not found in backup", "variable", envVar)
		}
	}

	// Create backup ConfigMap
	backupConfigMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      backupConfigMapName,
			Namespace: namespace,
			Labels: map[string]string{
				"app.kubernetes.io/name":      "liqo-upgrade",
				"app.kubernetes.io/component": "env-backup",
				"upgrade.liqo.io/upgrade":     upgrade.Name,
			},
		},
		Data: envData,
	}

	if err := controllerutil.SetControllerReference(upgrade, backupConfigMap, r.Scheme); err != nil {
		return fmt.Errorf("failed to set controller reference: %w", err)
	}

	// Create or update the ConfigMap
	existingConfigMap := &corev1.ConfigMap{}
	err = r.Get(ctx, types.NamespacedName{Name: backupConfigMapName, Namespace: namespace}, existingConfigMap)
	if err != nil {
		if errors.IsNotFound(err) {
			if err := r.Create(ctx, backupConfigMap); err != nil {
				return fmt.Errorf("failed to create backup ConfigMap: %w", err)
			}
			logger.Info("Environment config backup created", "configmap", backupConfigMapName)
		} else {
			return fmt.Errorf("failed to check backup ConfigMap: %w", err)
		}
	} else {
		// Update existing
		existingConfigMap.Data = envData
		if err := r.Update(ctx, existingConfigMap); err != nil {
			return fmt.Errorf("failed to update backup ConfigMap: %w", err)
		}
		logger.Info("Environment config backup updated", "configmap", backupConfigMapName)
	}

	// Store backup name in upgrade status for later use
	upgrade.Status.BackupName = backupConfigMapName
	upgrade.Status.BackupReady = true

	return nil
}

func (r *LiqoUpgradeReconciler) loadCompatibilityMatrix(ctx context.Context, namespace string) (CompatibilityMatrix, error) {
	configMap := &corev1.ConfigMap{}
	err := r.Get(ctx, types.NamespacedName{
		Name:      compatibilityConfigMap,
		Namespace: namespace,
	}, configMap)
	if err != nil {
		return nil, err
	}

	yamlData, ok := configMap.Data["compatibility.yaml"]
	if !ok {
		return nil, fmt.Errorf("compatibility.yaml not found in ConfigMap")
	}

	var matrix CompatibilityMatrix
	if err := yaml.Unmarshal([]byte(yamlData), &matrix); err != nil {
		return nil, err
	}

	return matrix, nil
}

func (r *LiqoUpgradeReconciler) isCompatible(matrix CompatibilityMatrix, sourceVersion, targetVersion string) bool {
	compatibleVersions, exists := matrix[sourceVersion]
	if !exists {
		return false
	}

	for _, compatible := range compatibleVersions {
		if compatible == targetVersion {
			return true
		}
	}
	return false
}

// getRemoteClusterVersions retrieves version information from all ForeignCluster CRs
func (r *LiqoUpgradeReconciler) getRemoteClusterVersions(ctx context.Context, localVersion string) ([]string, error) {
	logger := log.FromContext(ctx)

	// List all ForeignCluster resources
	foreignClusterList := &unstructured.UnstructuredList{}
	foreignClusterList.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "core.liqo.io",
		Version: "v1beta1",
		Kind:    "ForeignCluster",
	})

	if err := r.List(ctx, foreignClusterList); err != nil {
		return nil, fmt.Errorf("failed to list ForeignCluster resources: %w", err)
	}

	logger.Info("Found ForeignCluster resources", "count", len(foreignClusterList.Items))

	var remoteVersions []string
	for _, fc := range foreignClusterList.Items {
		clusterID := fc.GetName()

		// Extract status.remoteVersion if it exists
		remoteVersion, found, err := unstructured.NestedString(fc.Object, "status", "remoteVersion")
		if err != nil {
			logger.Info("Warning: failed to extract remoteVersion from ForeignCluster", "clusterID", clusterID, "error", err.Error())
			// If error accessing field, use local version as default
			remoteVersions = append(remoteVersions, localVersion)
			continue
		}

		if !found || remoteVersion == "" {
			// status.remoteVersion doesn't exist or is empty, use local version as default
			logger.Info("ForeignCluster has no remoteVersion, using local version", "clusterID", clusterID, "defaultVersion", localVersion)
			remoteVersions = append(remoteVersions, localVersion)
		} else {
			logger.Info("ForeignCluster version", "clusterID", clusterID, "version", remoteVersion)
			remoteVersions = append(remoteVersions, remoteVersion)
		}
	}

	return remoteVersions, nil
}

// findMinimumVersion finds the minimum version from a list of versions
func (r *LiqoUpgradeReconciler) findMinimumVersion(versions []string) string {
	if len(versions) == 0 {
		return ""
	}

	// Start with the first version as minimum
	minVersion := versions[0]

	// Compare with all other versions
	for _, version := range versions[1:] {
		if r.compareVersions(version, minVersion) < 0 {
			minVersion = version
		}
	}

	return minVersion
}

// compareVersions compares two version strings
// Returns: -1 if v1 < v2, 0 if v1 == v2, 1 if v1 > v2
func (r *LiqoUpgradeReconciler) compareVersions(v1, v2 string) int {
	// Remove 'v' prefix if present
	v1 = strings.TrimPrefix(v1, "v")
	v2 = strings.TrimPrefix(v2, "v")

	// Simple string comparison for semantic versions
	// This works for versions like "1.0.0", "1.0.1", etc.
	parts1 := strings.Split(v1, ".")
	parts2 := strings.Split(v2, ".")

	// Compare each part
	maxLen := len(parts1)
	if len(parts2) > maxLen {
		maxLen = len(parts2)
	}

	for i := 0; i < maxLen; i++ {
		var p1, p2 int
		if i < len(parts1) {
			fmt.Sscanf(parts1[i], "%d", &p1)
		}
		if i < len(parts2) {
			fmt.Sscanf(parts2[i], "%d", &p2)
		}

		if p1 < p2 {
			return -1
		} else if p1 > p2 {
			return 1
		}
	}

	return 0
}
